import { Subject } from 'rxjs';
/**
 * Rewires Observable to Relay-like Suspense resource.
 */
export class ObservableResource {
    /**
     * @param input$ An Observable.
     * @param isSuccess A function that determines if the value emitted from
     * `input$` is of success state. If false a Suspense is triggered.
     *  Default all true.
     */
    constructor(input$, isSuccess) {
        /**
         * Unlike Promise, Observable is a multiple push mechanism.
         * Only force update when Suspense needs to restart.
         */
        this.shouldUpdate$$ = new Subject();
        this.handler = this.getHandler();
        this.error = null;
        this.isSuccess = (value) => true;
        this._isDestroyed = false;
        this.handleNext = (value) => {
            this.error = null;
            if (this.isSuccess(value)) {
                const isDiff = this.value !== value;
                this.value = value;
                if (this.handler) {
                    // This will also remove the initial
                    // suspender if sync values are emitted.
                    const { resolve } = this.handler;
                    this.handler = null;
                    resolve();
                }
                if (isDiff) {
                    this.shouldUpdate$$.next({ current: value });
                }
            }
            else if (!this.handler) {
                // start a new Suspense
                this.handler = this.getHandler();
                this.shouldUpdate$$.next();
            }
        };
        this.handleError = (error) => {
            this.error = error;
            if (this.handler) {
                const { resolve } = this.handler;
                this.handler = null;
                // Errors thrown from the request is not catchable by error boundaries.
                // Here we resolve the suspender and let this.read throw the error.
                resolve();
            }
            else {
                this.shouldUpdate$$.next();
            }
        };
        this.handleComplete = () => {
            if (this.handler) {
                this.error = new Error('Suspender ended unexpectedly.');
                const { resolve } = this.handler;
                this.handler = null;
                // Errors thrown from the request is not catchable by error boundaries.
                // Here we resolve the suspender and let this.read throw the error.
                resolve();
            }
        };
        if (isSuccess) {
            this.isSuccess = isSuccess;
        }
        this.input$ = input$;
        this.subscription = input$.subscribe({
            next: this.handleNext,
            error: this.handleError,
            complete: this.handleComplete
        });
    }
    get isDestroyed() {
        return this._isDestroyed;
    }
    read() {
        if (this.error) {
            throw this.error;
        }
        if (this.handler) {
            throw this.handler.suspender;
        }
        return this.value;
    }
    reload(newInput$) {
        if (this._isDestroyed) {
            throw new Error('Cannot reload a destroyed Observable Resource');
        }
        if (newInput$) {
            this.input$ = newInput$;
        }
        this.subscription.unsubscribe();
        this.error = null;
        if (this.handler) {
            this.handler.resolve();
            this.handler = this.getHandler();
        }
        this.subscription = this.input$.subscribe({
            next: this.handleNext,
            error: this.handleError,
            complete: this.handleComplete
        });
    }
    destroy() {
        this._isDestroyed = true;
        this.subscription.unsubscribe();
        this.shouldUpdate$$.complete();
        if (this.handler) {
            this.error = new Error('Resource has been destroyed.');
            const { resolve } = this.handler;
            this.handler = null;
            resolve();
        }
    }
    getHandler() {
        const handler = {};
        handler.suspender = new Promise(resolve => {
            handler.resolve = resolve;
        });
        return handler;
    }
}
//# sourceMappingURL=observable-resource.js.map