import { Subject } from 'rxjs';
/**
 * Rewires Observable to Relay-like Suspense resource.
 */
var ObservableResource = /** @class */ (function () {
    /**
     * @param input$ An Observable.
     * @param isSuccess A function that determines if the value emitted from
     * `input$` is of success state. If false a Suspense is triggered.
     *  Default all true.
     */
    function ObservableResource(input$, isSuccess) {
        var _this = this;
        /**
         * Unlike Promise, Observable is a multiple push mechanism.
         * Only force update when Suspense needs to restart.
         */
        this.shouldUpdate$$ = new Subject();
        this.handler = this.getHandler();
        this.error = null;
        this.isSuccess = function (value) { return true; };
        this._isDestroyed = false;
        this.handleNext = function (value) {
            _this.error = null;
            if (_this.isSuccess(value)) {
                var isDiff = _this.value !== value;
                _this.value = value;
                if (_this.handler) {
                    // This will also remove the initial
                    // suspender if sync values are emitted.
                    var resolve = _this.handler.resolve;
                    _this.handler = null;
                    resolve();
                }
                if (isDiff) {
                    _this.shouldUpdate$$.next({ current: value });
                }
            }
            else if (!_this.handler) {
                // start a new Suspense
                _this.handler = _this.getHandler();
                _this.shouldUpdate$$.next();
            }
        };
        this.handleError = function (error) {
            _this.error = error;
            if (_this.handler) {
                var resolve = _this.handler.resolve;
                _this.handler = null;
                // Errors thrown from the request is not catchable by error boundaries.
                // Here we resolve the suspender and let this.read throw the error.
                resolve();
            }
            else {
                _this.shouldUpdate$$.next();
            }
        };
        this.handleComplete = function () {
            if (_this.handler) {
                _this.error = new Error('Suspender ended unexpectedly.');
                var resolve = _this.handler.resolve;
                _this.handler = null;
                // Errors thrown from the request is not catchable by error boundaries.
                // Here we resolve the suspender and let this.read throw the error.
                resolve();
            }
        };
        if (isSuccess) {
            this.isSuccess = isSuccess;
        }
        this.input$ = input$;
        this.subscription = input$.subscribe({
            next: this.handleNext,
            error: this.handleError,
            complete: this.handleComplete
        });
    }
    Object.defineProperty(ObservableResource.prototype, "isDestroyed", {
        get: function () {
            return this._isDestroyed;
        },
        enumerable: false,
        configurable: true
    });
    ObservableResource.prototype.read = function () {
        if (this.error) {
            throw this.error;
        }
        if (this.handler) {
            throw this.handler.suspender;
        }
        return this.value;
    };
    ObservableResource.prototype.reload = function (newInput$) {
        if (this._isDestroyed) {
            throw new Error('Cannot reload a destroyed Observable Resource');
        }
        if (newInput$) {
            this.input$ = newInput$;
        }
        this.subscription.unsubscribe();
        this.error = null;
        if (this.handler) {
            this.handler.resolve();
            this.handler = this.getHandler();
        }
        this.subscription = this.input$.subscribe({
            next: this.handleNext,
            error: this.handleError,
            complete: this.handleComplete
        });
    };
    ObservableResource.prototype.destroy = function () {
        this._isDestroyed = true;
        this.subscription.unsubscribe();
        this.shouldUpdate$$.complete();
        if (this.handler) {
            this.error = new Error('Resource has been destroyed.');
            var resolve = this.handler.resolve;
            this.handler = null;
            resolve();
        }
    };
    ObservableResource.prototype.getHandler = function () {
        var handler = {};
        handler.suspender = new Promise(function (resolve) {
            handler.resolve = resolve;
        });
        return handler;
    };
    return ObservableResource;
}());
export { ObservableResource };
//# sourceMappingURL=observable-resource.js.map