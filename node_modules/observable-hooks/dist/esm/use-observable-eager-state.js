import { useState, useDebugValue, useEffect, useRef } from 'react';
import { useForceUpdate, useIsomorphicLayoutEffect } from './helpers';
/**
 * Optimized for safely getting synchronous values from hot or pure observables
 * without triggering extra initial re-rendering.
 *
 * âš  If the observable is cold and with side effects
 * they will be performed at least twice!
 *
 * By default this hook will subscribe to the observable at least twice.
 * The first time is for getting synchronous value to prevent extra initial re-rendering.
 * In concurrent mode this may happen more than one time.
 *
 * @template TState State.
 *
 * @param state$ An observable of state value.
 */
export function useObservableEagerState(state$) {
    var forceUpdate = useForceUpdate();
    var state$Ref = useRef(state$);
    var errorRef = useRef();
    var isAsyncEmissionRef = useRef(false);
    var didSyncEmit = useRef(false);
    var _a = useState(function () {
        var state;
        state$
            .subscribe({
            next: function (value) {
                didSyncEmit.current = true;
                state = value;
            },
            error: function (error) {
                errorRef.current = error;
            }
        })
            .unsubscribe();
        return state;
    }), state = _a[0], setState = _a[1];
    // update the latest observable
    // synchronously after render being committed
    useIsomorphicLayoutEffect(function () {
        state$Ref.current = state$;
    });
    useEffect(function () {
        errorRef.current = null;
        // keep in closure for checking staleness
        var input$ = state$Ref.current;
        var subscription = input$.subscribe({
            next: function (value) {
                if (input$ !== state$Ref.current) {
                    // stale observable
                    return;
                }
                if (isAsyncEmissionRef.current) {
                    // ignore synchronous value
                    // prevent initial re-rendering
                    setState(value);
                }
            },
            error: function (error) {
                if (input$ !== state$Ref.current) {
                    // stale observable
                    return;
                }
                errorRef.current = error;
                forceUpdate();
            }
        });
        isAsyncEmissionRef.current = true;
        return function () {
            subscription.unsubscribe();
        };
    }, [state$]);
    if (errorRef.current) {
        // Let error boundary catch the error
        throw errorRef.current;
    }
    if (didSyncEmit.current) {
        useDebugValue(state);
        return state;
    }
    else {
        throw new Error('Observable did not synchronously emit a value.');
    }
}
//# sourceMappingURL=use-observable-eager-state.js.map