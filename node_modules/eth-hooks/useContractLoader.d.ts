import { Contract } from '@ethersproject/contracts';
import { TDeployedContracts, TExternalContracts, TEthersProviderOrSigner } from "./models";
/**
 * Configuration for useContractLoader
 */
export declare type TContractConfig = {
    hardhatNetworkName?: string;
    customAddresses?: Record<string, string>;
    deployedContracts?: TDeployedContracts;
    externalContracts?: TExternalContracts;
};
/**
 * Loads your local contracts and gives options to read values from contracts
  or write transactions into them

   ~ Features ~
  - localProvider enables reading values from contracts
  - userProvider enables writing transactions into contracts
  - Example of keeping track of "purpose" variable by loading contracts into readContracts
    and using ContractReader.js hook:
    const purpose = useContractReader(readContracts,"YourContract", "purpose")
  - Example of using setPurpose function from our contract and writing transactions by Transactor.js helper:
    tx( writeContracts.YourContract.setPurpose(newPurpose) )

  config can include:
  - chainId - to hardcode the chainId, irrespective of the providerOrSigner chainId
  - hardhatNetworkName - to hardcode the hardhat network of interest
  - customAddresses: { contractName: 0xCustomAddress } to hardcode the address for a given named contract
  - hardhatContracts: object following the hardhat deploy export format (Json with chainIds as keys, which have hardhat network names as keys, which contain arrays of contracts for each)
  - externalContracts: object with chainIds as keys, with an array of contracts for each
 * @param providerOrSigner (TEthersProviderOrSigner)
 * @param config (TContractConfig) :: configuration for loader
 * @returns (Record<string, Contract>) :: a record of contractName:contract
 */
export declare const useContractLoader: (providerOrSigner: TEthersProviderOrSigner | undefined, config?: TContractConfig, chainId?: number | undefined) => Record<string, Contract>;
//# sourceMappingURL=useContractLoader.d.ts.map