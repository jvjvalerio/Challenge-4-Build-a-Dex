interface AssetTypeInput {
    assetStandard: string;
    assetContractAddress: string;
    quantum: string;
    amount?: string | null;
}
interface IDeposit extends Partial<AssetTypeInput> {
    vaultId: string;
}
export interface ITransferInput extends Partial<AssetTypeInput> {
    from?: any;
    to?: any;
    asset?: any;
    assetType?: string;
    quantizedAmount?: string;
    nonce: string;
    senderVaultId?: string;
    receiverVaultId?: string;
    receiverKey?: string;
    expirationTimestamp: string;
    condition?: string;
    conditionalTransferAddress?: string;
    conditionalTransferFact?: string;
}
export interface ICreateOrderInput {
    vaultSell: string;
    vaultBuy: string;
    amountSell: string;
    amountBuy: string;
    tokenSellAssetType: string;
    tokenBuyAssetType: string;
    nonce: string;
    expirationTimestamp: string;
}
declare class StarkWareProvider {
    authereum: any;
    constructor(authereum: any);
    send: (method: string, params: any) => Promise<any>;
    getStarkKey: () => Promise<string>;
    getPublicKey: () => Promise<string>;
    getEthAddress: () => Promise<string>;
    signNonce: (nonce: string | number) => Promise<string>;
    starkSignMessage: (message: string) => Promise<string>;
    setContractAddress: (contractAddress: string) => Promise<string>;
    getContractAddress: () => Promise<string>;
    registerUser: (ethKey: string, operatorSignature: string) => Promise<string>;
    deposit: (input: IDeposit) => Promise<string>;
    depositEth: (vaultId: string, amount: string, quantum: string) => Promise<string>;
    depositErc20: (vaultId: string, amount: string, quantum: string, token: string) => Promise<string>;
    depositErc721: (vaultId: string, tokenId: string, token: string) => Promise<string>;
    cancelDeposit: (vaultId: string, assetType: string) => Promise<string>;
    cancelEthDeposit: (vaultId: string, quantum: string) => Promise<string>;
    cancelErc20Deposit: (vaultId: string, quantum: string, token: string) => Promise<string>;
    cancelErc721Deposit: (vaultId: string, tokenId: string, token: string) => Promise<string>;
    reclaimDeposit: (vaultId: string, assetType: string) => Promise<string>;
    reclaimEthDeposit: (vaultId: string, quantum: string) => Promise<string>;
    reclaimErc20Deposit: (vaultId: string, quantum: string, token: string) => Promise<string>;
    reclaimErc721Deposit: (vaultId: string, tokenId: string, token: string) => Promise<string>;
    withdraw: (assetStandard: string, quantum?: string, assetContractAddress?: string, recipient?: string) => Promise<string>;
    withdrawEth: (quantum: string, recipient?: string) => Promise<string>;
    withdrawErc20: (quantum: string, token: string, recipient?: string) => Promise<string>;
    withdrawErc721: (tokenId: string, token: string, recipient?: string) => Promise<string>;
    fullWithdrawalRequest: (vaultId: string) => Promise<string>;
    withdrawAndMint: (assetType: string, mintingBlob: string) => Promise<string>;
    freezeRequest: (vaultId: string) => Promise<string>;
    escape: (vaultId: string, assetType: string, quantizedAmount: string) => Promise<string>;
    transfer: (input: ITransferInput) => Promise<string>;
    transferEth: (input: ITransferInput) => Promise<string>;
    transferErc20: (input: ITransferInput) => Promise<string>;
    transferErc721: (input: ITransferInput) => Promise<string>;
    createOrder: (input: ICreateOrderInput) => Promise<string>;
    getAssetType: (input: AssetTypeInput) => Promise<string>;
    getConditionHash: (...params: string[]) => Promise<string>;
    signTransaction: (tx: any) => Promise<any>;
    sendTransaction: (tx: any) => Promise<any>;
    signMessage: (msg: any, opts?: any) => Promise<any>;
    signPersonalMessage: (msg: string) => Promise<any>;
    getAccountAddress: () => Promise<any>;
    estimateGas: (tx: any) => Promise<any>;
}
export default StarkWareProvider;
