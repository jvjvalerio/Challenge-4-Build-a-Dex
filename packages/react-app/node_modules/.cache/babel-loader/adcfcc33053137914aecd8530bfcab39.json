{"ast":null,"code":"import { useState, useEffect, useCallback, useMemo } from 'react';\n\nconst getEventKey = m => {\n  return `${m.transactionHash}_${m.logIndex}`;\n};\n/**\n * Enables you to keep track of events\n *\n * ~ Features ~\n  - Provide readContracts by loading contracts (see more on ContractLoader.js)\n  - Specify the name of the contract, in this case it is \"YourContract\"\n  - Specify the name of the event in the contract, in this case we keep track of \"SetPurpose\" event\n  - Specify the provider\n * @param contracts (Record<string, Contract>) :: record of current contractname/contract\n * @param contractName (string) :: name of the contract you are interested in\n * @param eventName (string) :: name of the event\n * @param provider (TEthersProvider)\n * @param startBlock (number) string block of events\n * @returns (ethers->Event)\n */\n\n\nexport const useEventListener = (contracts, contractName, eventName, provider, startBlock) => {\n  const [eventMap, setEventMap] = useState(new Map());\n  const deps = JSON.stringify([...eventMap]);\n  const events = useMemo(() => [...eventMap].map(m => m[1]), [deps]);\n  const addNewEvent = useCallback((...listenerArgs) => {\n    if (listenerArgs != null && listenerArgs.length > 0) {\n      const newEvent = listenerArgs[listenerArgs.length - 1];\n\n      if (newEvent.event != null && newEvent.logIndex != null && newEvent.transactionHash != null) {\n        const newMap = new Map([[getEventKey(newEvent), newEvent]]);\n        setEventMap(oldMap => new Map([...oldMap, ...newMap]));\n      }\n    }\n  }, [setEventMap]);\n  useEffect(() => {\n    if (provider) {\n      // if you want to read _all_ events from your contracts, set this to the block number it is deployed\n      provider.resetEventsBlock(startBlock);\n    }\n\n    if ((contracts === null || contracts === void 0 ? void 0 : contracts[contractName]) != null) {\n      try {\n        contracts[contractName].on(eventName, addNewEvent);\n        return () => {\n          contracts[contractName].off(eventName, addNewEvent);\n        };\n      } catch (e) {\n        console.log(e);\n      }\n    }\n  }, [provider, startBlock, contracts, contractName, eventName, addNewEvent]);\n  return events;\n};","map":{"version":3,"sources":["/Users/untitled/challenge-4-single-pool-dex/node_modules/eth-hooks/events/useEventListener.js"],"names":["useState","useEffect","useCallback","useMemo","getEventKey","m","transactionHash","logIndex","useEventListener","contracts","contractName","eventName","provider","startBlock","eventMap","setEventMap","Map","deps","JSON","stringify","events","map","addNewEvent","listenerArgs","length","newEvent","event","newMap","oldMap","resetEventsBlock","on","off","e","console","log"],"mappings":"AAAA,SAASA,QAAT,EAAmBC,SAAnB,EAA8BC,WAA9B,EAA2CC,OAA3C,QAA0D,OAA1D;;AACA,MAAMC,WAAW,GAAIC,CAAD,IAAO;AACvB,SAAQ,GAAEA,CAAC,CAACC,eAAgB,IAAGD,CAAC,CAACE,QAAS,EAA1C;AACH,CAFD;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,OAAO,MAAMC,gBAAgB,GAAG,CAACC,SAAD,EAAYC,YAAZ,EAA0BC,SAA1B,EAAqCC,QAArC,EAA+CC,UAA/C,KAA8D;AAC1F,QAAM,CAACC,QAAD,EAAWC,WAAX,IAA0Bf,QAAQ,CAAC,IAAIgB,GAAJ,EAAD,CAAxC;AACA,QAAMC,IAAI,GAAGC,IAAI,CAACC,SAAL,CAAe,CAAC,GAAGL,QAAJ,CAAf,CAAb;AACA,QAAMM,MAAM,GAAGjB,OAAO,CAAC,MAAM,CAAC,GAAGW,QAAJ,EAAcO,GAAd,CAAmBhB,CAAD,IAAOA,CAAC,CAAC,CAAD,CAA1B,CAAP,EAAuC,CAACY,IAAD,CAAvC,CAAtB;AACA,QAAMK,WAAW,GAAGpB,WAAW,CAAC,CAAC,GAAGqB,YAAJ,KAAqB;AACjD,QAAIA,YAAY,IAAI,IAAhB,IAAwBA,YAAY,CAACC,MAAb,GAAsB,CAAlD,EAAqD;AACjD,YAAMC,QAAQ,GAAGF,YAAY,CAACA,YAAY,CAACC,MAAb,GAAsB,CAAvB,CAA7B;;AACA,UAAIC,QAAQ,CAACC,KAAT,IAAkB,IAAlB,IAA0BD,QAAQ,CAAClB,QAAT,IAAqB,IAA/C,IAAuDkB,QAAQ,CAACnB,eAAT,IAA4B,IAAvF,EAA6F;AACzF,cAAMqB,MAAM,GAAG,IAAIX,GAAJ,CAAQ,CAAC,CAACZ,WAAW,CAACqB,QAAD,CAAZ,EAAwBA,QAAxB,CAAD,CAAR,CAAf;AACAV,QAAAA,WAAW,CAAEa,MAAD,IAAY,IAAIZ,GAAJ,CAAQ,CAAC,GAAGY,MAAJ,EAAY,GAAGD,MAAf,CAAR,CAAb,CAAX;AACH;AACJ;AACJ,GAR8B,EAQ5B,CAACZ,WAAD,CAR4B,CAA/B;AASAd,EAAAA,SAAS,CAAC,MAAM;AACZ,QAAIW,QAAJ,EAAc;AACV;AACAA,MAAAA,QAAQ,CAACiB,gBAAT,CAA0BhB,UAA1B;AACH;;AACD,QAAI,CAACJ,SAAS,KAAK,IAAd,IAAsBA,SAAS,KAAK,KAAK,CAAzC,GAA6C,KAAK,CAAlD,GAAsDA,SAAS,CAACC,YAAD,CAAhE,KAAmF,IAAvF,EAA6F;AACzF,UAAI;AACAD,QAAAA,SAAS,CAACC,YAAD,CAAT,CAAwBoB,EAAxB,CAA2BnB,SAA3B,EAAsCW,WAAtC;AACA,eAAO,MAAM;AACTb,UAAAA,SAAS,CAACC,YAAD,CAAT,CAAwBqB,GAAxB,CAA4BpB,SAA5B,EAAuCW,WAAvC;AACH,SAFD;AAGH,OALD,CAMA,OAAOU,CAAP,EAAU;AACNC,QAAAA,OAAO,CAACC,GAAR,CAAYF,CAAZ;AACH;AACJ;AACJ,GAhBQ,EAgBN,CAACpB,QAAD,EAAWC,UAAX,EAAuBJ,SAAvB,EAAkCC,YAAlC,EAAgDC,SAAhD,EAA2DW,WAA3D,CAhBM,CAAT;AAiBA,SAAOF,MAAP;AACH,CA/BM","sourcesContent":["import { useState, useEffect, useCallback, useMemo } from 'react';\nconst getEventKey = (m) => {\n    return `${m.transactionHash}_${m.logIndex}`;\n};\n/**\n * Enables you to keep track of events\n *\n * ~ Features ~\n  - Provide readContracts by loading contracts (see more on ContractLoader.js)\n  - Specify the name of the contract, in this case it is \"YourContract\"\n  - Specify the name of the event in the contract, in this case we keep track of \"SetPurpose\" event\n  - Specify the provider\n * @param contracts (Record<string, Contract>) :: record of current contractname/contract\n * @param contractName (string) :: name of the contract you are interested in\n * @param eventName (string) :: name of the event\n * @param provider (TEthersProvider)\n * @param startBlock (number) string block of events\n * @returns (ethers->Event)\n */\nexport const useEventListener = (contracts, contractName, eventName, provider, startBlock) => {\n    const [eventMap, setEventMap] = useState(new Map());\n    const deps = JSON.stringify([...eventMap]);\n    const events = useMemo(() => [...eventMap].map((m) => m[1]), [deps]);\n    const addNewEvent = useCallback((...listenerArgs) => {\n        if (listenerArgs != null && listenerArgs.length > 0) {\n            const newEvent = listenerArgs[listenerArgs.length - 1];\n            if (newEvent.event != null && newEvent.logIndex != null && newEvent.transactionHash != null) {\n                const newMap = new Map([[getEventKey(newEvent), newEvent]]);\n                setEventMap((oldMap) => new Map([...oldMap, ...newMap]));\n            }\n        }\n    }, [setEventMap]);\n    useEffect(() => {\n        if (provider) {\n            // if you want to read _all_ events from your contracts, set this to the block number it is deployed\n            provider.resetEventsBlock(startBlock);\n        }\n        if ((contracts === null || contracts === void 0 ? void 0 : contracts[contractName]) != null) {\n            try {\n                contracts[contractName].on(eventName, addNewEvent);\n                return () => {\n                    contracts[contractName].off(eventName, addNewEvent);\n                };\n            }\n            catch (e) {\n                console.log(e);\n            }\n        }\n    }, [provider, startBlock, contracts, contractName, eventName, addNewEvent]);\n    return events;\n};\n"]},"metadata":{},"sourceType":"module"}