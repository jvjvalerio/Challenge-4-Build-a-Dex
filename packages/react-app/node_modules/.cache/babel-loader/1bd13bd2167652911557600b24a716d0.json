{"ast":null,"code":"import { useMemo, useState } from 'react';\nimport { useBurnerSigner } from \"./\";\nimport { parseProviderOrSigner } from \"./functions/providerOrSigner\";\n\nconst syncBurnerKeyFromStorage = () => {\n  if (window.location.pathname && window.location.pathname.includes('/pk')) {\n    const incomingPK = window.location.hash.replace('#', '');\n\n    if (incomingPK.length === 64 || incomingPK.length === 66) {\n      console.log('ðŸ”‘ Incoming Private Key...');\n      const rawPK = incomingPK;\n      window.history.pushState({}, '', '/');\n      const currentPrivateKey = window.localStorage.getItem('metaPrivateKey');\n\n      if (currentPrivateKey && currentPrivateKey !== rawPK) {\n        window.localStorage.setItem(`metaPrivateKey_backup${Date.now()}`, currentPrivateKey);\n      }\n\n      window.localStorage.setItem('metaPrivateKey', rawPK);\n    }\n  }\n};\n/**\n *  Gets user provider/signer from injected provider or local provider\n *  Use your injected provider from ðŸ¦Š Metamask\n *  If you don't have it then instantly generate a ðŸ”¥ burner wallet from a local provider\n *\n  ~ Features ~\n  - Specify the injected provider from Metamask\n  - Specify the local provider\n  - Usage examples:\n    const tx = Transactor(userSigner, gasPrice)\n * @param injectedProviderOrSigner (TEthersProviderOrSigner) :: injected provider/signer from metamask etc..\n * @param localProvider (TEthersProvider) local provider to generate a burner wallet from\n * @param useBurnerWallet (boolean) lets the hook know wether to use the burner wallet or not\n * @returns (TProviderAndSigner)\n */\n\n\nexport const useUserProviderAndSigner = (injectedProviderOrSigner, localProvider, useBurnerWallet) => {\n  const [signer, setSigner] = useState();\n  const [provider, setProvider] = useState();\n  const [providerNetwork, setProviderNetwork] = useState();\n  const burnerSigner = useBurnerSigner(localProvider);\n  useMemo(() => {\n    if (injectedProviderOrSigner) {\n      console.log('ðŸ¦Š Using injected provider');\n      void parseProviderOrSigner(injectedProviderOrSigner).then(result => {\n        if (result != null) setSigner(result.signer);\n      });\n    } else if (!localProvider) {\n      setSigner(undefined);\n    } else if (useBurnerWallet) {\n      syncBurnerKeyFromStorage();\n      console.log('ðŸ”¥ Using burner signer', burnerSigner);\n      setSigner(burnerSigner);\n    } else {\n      console.log(\"burner is off\");\n    }\n  }, [injectedProviderOrSigner, localProvider, burnerSigner]);\n  useMemo(() => {\n    if (signer) {\n      const result = parseProviderOrSigner(signer);\n      void result.then(r => {\n        setProvider(r.provider);\n        setProviderNetwork(r.providerNetwork);\n      });\n    }\n  }, [signer]);\n  return {\n    signer,\n    provider,\n    providerNetwork\n  };\n};","map":{"version":3,"sources":["/Users/untitled/challenge-4-single-pool-dex/node_modules/eth-hooks/useUserProviderAndSigner.js"],"names":["useMemo","useState","useBurnerSigner","parseProviderOrSigner","syncBurnerKeyFromStorage","window","location","pathname","includes","incomingPK","hash","replace","length","console","log","rawPK","history","pushState","currentPrivateKey","localStorage","getItem","setItem","Date","now","useUserProviderAndSigner","injectedProviderOrSigner","localProvider","useBurnerWallet","signer","setSigner","provider","setProvider","providerNetwork","setProviderNetwork","burnerSigner","then","result","undefined","r"],"mappings":"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","sourcesContent":["import { useMemo, useState } from 'react';\nimport { useBurnerSigner } from \"./\";\nimport { parseProviderOrSigner } from \"./functions/providerOrSigner\";\nconst syncBurnerKeyFromStorage = () => {\n    if (window.location.pathname && window.location.pathname.includes('/pk')) {\n        const incomingPK = window.location.hash.replace('#', '');\n        if (incomingPK.length === 64 || incomingPK.length === 66) {\n            console.log('ðŸ”‘ Incoming Private Key...');\n            const rawPK = incomingPK;\n            window.history.pushState({}, '', '/');\n            const currentPrivateKey = window.localStorage.getItem('metaPrivateKey');\n            if (currentPrivateKey && currentPrivateKey !== rawPK) {\n                window.localStorage.setItem(`metaPrivateKey_backup${Date.now()}`, currentPrivateKey);\n            }\n            window.localStorage.setItem('metaPrivateKey', rawPK);\n        }\n    }\n};\n/**\n *  Gets user provider/signer from injected provider or local provider\n *  Use your injected provider from ðŸ¦Š Metamask\n *  If you don't have it then instantly generate a ðŸ”¥ burner wallet from a local provider\n *\n  ~ Features ~\n  - Specify the injected provider from Metamask\n  - Specify the local provider\n  - Usage examples:\n    const tx = Transactor(userSigner, gasPrice)\n * @param injectedProviderOrSigner (TEthersProviderOrSigner) :: injected provider/signer from metamask etc..\n * @param localProvider (TEthersProvider) local provider to generate a burner wallet from\n * @param useBurnerWallet (boolean) lets the hook know wether to use the burner wallet or not\n * @returns (TProviderAndSigner)\n */\nexport const useUserProviderAndSigner = (injectedProviderOrSigner, localProvider, useBurnerWallet) => {\n    const [signer, setSigner] = useState();\n    const [provider, setProvider] = useState();\n    const [providerNetwork, setProviderNetwork] = useState();\n    const burnerSigner = useBurnerSigner(localProvider);\n    useMemo(() => {\n        if (injectedProviderOrSigner) {\n            console.log('ðŸ¦Š Using injected provider');\n            void parseProviderOrSigner(injectedProviderOrSigner).then((result) => {\n                if (result != null)\n                    setSigner(result.signer);\n            });\n        }\n        else if (!localProvider) {\n            setSigner(undefined);\n        }\n        else if (useBurnerWallet) {\n            syncBurnerKeyFromStorage();\n            console.log('ðŸ”¥ Using burner signer', burnerSigner);\n            setSigner(burnerSigner);\n        }\n        else {\n            console.log(\"burner is off\");\n        }\n    }, [injectedProviderOrSigner, localProvider, burnerSigner]);\n    useMemo(() => {\n        if (signer) {\n            const result = parseProviderOrSigner(signer);\n            void result.then((r) => {\n                setProvider(r.provider);\n                setProviderNetwork(r.providerNetwork);\n            });\n        }\n    }, [signer]);\n    return { signer, provider, providerNetwork };\n};\n"]},"metadata":{},"sourceType":"module"}