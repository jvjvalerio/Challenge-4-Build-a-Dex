{"ast":null,"code":"import _regeneratorRuntime from\"/Users/untitled/challenge-4-single-pool-dex/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\";import _asyncToGenerator from\"/Users/untitled/challenge-4-single-pool-dex/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";import _slicedToArray from\"/Users/untitled/challenge-4-single-pool-dex/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/slicedToArray\";import{Input}from\"antd\";import React,{useEffect,useState}from\"react\";import{jsx as _jsx}from\"react/jsx-runtime\";var _require=require(\"ethers\"),utils=_require.utils,constants=_require.constants;/*\n  ~ What it does? ~\n\n  Displays input field with options to convert between STRING and BYTES32\n\n  ~ How can I use? ~\n\n  <BytesStringInput\n    autofocus\n    value={\"scaffold-eth\"}\n    placeholder=\"Enter value...\"\n    onChange={value => {\n      setValue(value);\n    }}\n  />\n\n  ~ Features ~\n\n  - Provide value={value} to specify initial string\n  - Provide placeholder=\"Enter value...\" value for the input\n  - Control input change by onChange={value => { setValue(value);}}\n\n*/export default function BytesStringInput(props){var _useState=useState(\"STRING\"),_useState2=_slicedToArray(_useState,2),mode=_useState2[0],setMode=_useState2[1];var _useState3=useState(),_useState4=_slicedToArray(_useState3,2),display=_useState4[0],setDisplay=_useState4[1];var _useState5=useState(constants.HashZero),_useState6=_slicedToArray(_useState5,2),value=_useState6[0],setValue=_useState6[1];// current value is the value in bytes32\nvar currentValue=typeof props.value!==\"undefined\"?props.value:value;var option=function option(title){return/*#__PURE__*/_jsx(\"div\",{style:{cursor:\"pointer\"},onClick:function onClick(){if(mode===\"STRING\"){setMode(\"BYTES32\");if(!utils.isHexString(currentValue)){/* in case user enters invalid bytes32 number,\n                   it considers it as string and converts to bytes32 */var changedValue=utils.formatBytes32String(currentValue);setDisplay(changedValue);}else{setDisplay(currentValue);}}else{setMode(\"STRING\");if(currentValue&&utils.isHexString(currentValue)){setDisplay(utils.parseBytes32String(currentValue));}else{setDisplay(currentValue);}}},children:title});};var addonAfter;if(mode===\"STRING\"){addonAfter=option(\"STRING ðŸ”€\");}else{addonAfter=option(\"BYTES32 ðŸ”€\");}useEffect(function(){if(!currentValue){setDisplay(\"\");}},[currentValue]);return/*#__PURE__*/_jsx(Input,{placeholder:props.placeholder?props.placeholder:\"Enter value in \"+mode,autoFocus:props.autoFocus,value:display,addonAfter:addonAfter,onChange:/*#__PURE__*/function(){var _ref=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee(e){var newValue;return _regeneratorRuntime.wrap(function _callee$(_context){while(1){switch(_context.prev=_context.next){case 0:newValue=e.target.value;if(mode===\"STRING\"){// const ethValue = parseFloat(newValue) / props.price;\n// setValue(ethValue);\nif(typeof props.onChange===\"function\"){props.onChange(utils.formatBytes32String(newValue));}setValue(utils.formatBytes32String(newValue));setDisplay(newValue);}else{if(typeof props.onChange===\"function\"){props.onChange(newValue);}setValue(newValue);setDisplay(newValue);}case 2:case\"end\":return _context.stop();}}},_callee);}));return function(_x){return _ref.apply(this,arguments);};}()});}","map":{"version":3,"sources":["/Users/untitled/challenge-4-single-pool-dex/packages/react-app/src/components/BytesStringInput.jsx"],"names":["Input","React","useEffect","useState","require","utils","constants","BytesStringInput","props","mode","setMode","display","setDisplay","HashZero","value","setValue","currentValue","option","title","cursor","isHexString","changedValue","formatBytes32String","parseBytes32String","addonAfter","placeholder","autoFocus","e","newValue","target","onChange"],"mappings":"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","sourcesContent":["import { Input } from \"antd\";\nimport React, { useEffect, useState } from \"react\";\n\nconst { utils, constants } = require(\"ethers\");\n\n/*\n  ~ What it does? ~\n\n  Displays input field with options to convert between STRING and BYTES32\n\n  ~ How can I use? ~\n\n  <BytesStringInput\n    autofocus\n    value={\"scaffold-eth\"}\n    placeholder=\"Enter value...\"\n    onChange={value => {\n      setValue(value);\n    }}\n  />\n\n  ~ Features ~\n\n  - Provide value={value} to specify initial string\n  - Provide placeholder=\"Enter value...\" value for the input\n  - Control input change by onChange={value => { setValue(value);}}\n\n*/\n\nexport default function BytesStringInput(props) {\n  const [mode, setMode] = useState(\"STRING\");\n  const [display, setDisplay] = useState();\n  const [value, setValue] = useState(constants.HashZero);\n\n  // current value is the value in bytes32\n  const currentValue = typeof props.value !== \"undefined\" ? props.value : value;\n\n  const option = title => {\n    return (\n      <div\n        style={{ cursor: \"pointer\" }}\n        onClick={() => {\n          if (mode === \"STRING\") {\n            setMode(\"BYTES32\");\n            if (!utils.isHexString(currentValue)) {\n              /* in case user enters invalid bytes32 number,\n                   it considers it as string and converts to bytes32 */\n              const changedValue = utils.formatBytes32String(currentValue);\n              setDisplay(changedValue);\n            } else {\n              setDisplay(currentValue);\n            }\n          } else {\n            setMode(\"STRING\");\n            if (currentValue && utils.isHexString(currentValue)) {\n              setDisplay(utils.parseBytes32String(currentValue));\n            } else {\n              setDisplay(currentValue);\n            }\n          }\n        }}\n      >\n        {title}\n      </div>\n    );\n  };\n\n  let addonAfter;\n  if (mode === \"STRING\") {\n    addonAfter = option(\"STRING ðŸ”€\");\n  } else {\n    addonAfter = option(\"BYTES32 ðŸ”€\");\n  }\n\n  useEffect(() => {\n    if (!currentValue) {\n      setDisplay(\"\");\n    }\n  }, [currentValue]);\n\n  return (\n    <Input\n      placeholder={props.placeholder ? props.placeholder : \"Enter value in \" + mode}\n      autoFocus={props.autoFocus}\n      value={display}\n      addonAfter={addonAfter}\n      onChange={async e => {\n        const newValue = e.target.value;\n        if (mode === \"STRING\") {\n          // const ethValue = parseFloat(newValue) / props.price;\n          // setValue(ethValue);\n          if (typeof props.onChange === \"function\") {\n            props.onChange(utils.formatBytes32String(newValue));\n          }\n          setValue(utils.formatBytes32String(newValue));\n          setDisplay(newValue);\n        } else {\n          if (typeof props.onChange === \"function\") {\n            props.onChange(newValue);\n          }\n          setValue(newValue);\n          setDisplay(newValue);\n        }\n      }}\n    />\n  );\n}\n"]},"metadata":{},"sourceType":"module"}