{"ast":null,"code":"import { notification } from \"antd\";\nimport Notify from \"bnc-notify\";\nimport { BLOCKNATIVE_DAPPID } from \"../constants\";\n\nconst {\n  ethers\n} = require(\"ethers\"); // this should probably just be renamed to \"notifier\"\n// it is basically just a wrapper around BlockNative's wonderful Notify.js\n// https://docs.blocknative.com/notify\n\n\nconst callbacks = {};\nconst DEBUG = true;\nexport default function Transactor(providerOrSigner, gasPrice, etherscan) {\n  if (typeof providerOrSigner !== \"undefined\") {\n    // eslint-disable-next-line consistent-return\n    return async (tx, callback) => {\n      let signer;\n      let network;\n      let provider;\n\n      if (ethers.Signer.isSigner(providerOrSigner) === true) {\n        provider = providerOrSigner.provider;\n        signer = providerOrSigner;\n        network = providerOrSigner.provider && (await providerOrSigner.provider.getNetwork());\n      } else if (providerOrSigner._isProvider) {\n        provider = providerOrSigner;\n        signer = providerOrSigner.getSigner();\n        network = await providerOrSigner.getNetwork();\n      }\n\n      console.log(\"network\", network);\n      var options = null;\n      var notify = null;\n      options = {\n        dappId: BLOCKNATIVE_DAPPID,\n        // GET YOUR OWN KEY AT https://account.blocknative.com\n        system: \"ethereum\",\n        networkId: network.chainId,\n        // darkMode: Boolean, // (default: false)\n        transactionHandler: txInformation => {\n          if (DEBUG) console.log(\"HANDLE TX\", txInformation);\n          const possibleFunction = callbacks[txInformation.transaction.hash];\n\n          if (typeof possibleFunction === \"function\") {\n            possibleFunction(txInformation.transaction);\n          }\n        }\n      };\n      notify = Notify(options);\n      let etherscanNetwork = \"\";\n\n      if (network.name && network.chainId > 1) {\n        etherscanNetwork = network.name + \".\";\n      }\n\n      let etherscanTxUrl = \"https://\" + etherscanNetwork + \"etherscan.io/tx/\";\n\n      if (network.chainId === 100) {\n        etherscanTxUrl = \"https://blockscout.com/poa/xdai/tx/\";\n      }\n\n      try {\n        let result;\n\n        if (tx instanceof Promise) {\n          if (DEBUG) console.log(\"AWAITING TX\", tx);\n          result = await tx;\n        } else {\n          if (!tx.gasPrice) {\n            tx.gasPrice = gasPrice || ethers.utils.parseUnits(\"4.1\", \"gwei\");\n          }\n\n          if (!tx.gasLimit) {\n            tx.gasLimit = ethers.utils.hexlify(120000);\n          }\n\n          if (DEBUG) console.log(\"RUNNING TX\", tx);\n          result = await signer.sendTransaction(tx);\n        }\n\n        if (DEBUG) console.log(\"RESULT:\", result); // console.log(\"Notify\", notify);\n\n        if (callback) {\n          callbacks[result.hash] = callback;\n        } // if it is a valid Notify.js network, use that, if not, just send a default notification\n\n\n        if (notify && [1, 3, 4, 5, 42, 100].indexOf(network.chainId) >= 0) {\n          const {\n            emitter\n          } = notify.hash(result.hash);\n          emitter.on(\"all\", transaction => {\n            return {\n              onclick: () => window.open((etherscan || etherscanTxUrl) + transaction.hash)\n            };\n          });\n        } else {\n          notification.info({\n            message: \"Local Transaction Sent\",\n            description: result.hash,\n            placement: \"bottomRight\"\n          }); // on most networks BlockNative will update a transaction handler,\n          // but locally we will set an interval to listen...\n\n          if (callback) {\n            const txResult = await tx;\n            const listeningInterval = setInterval(async () => {\n              console.log(\"CHECK IN ON THE TX\", txResult, provider);\n              const currentTransactionReceipt = await provider.getTransactionReceipt(txResult.hash);\n\n              if (currentTransactionReceipt && currentTransactionReceipt.confirmations) {\n                callback({ ...txResult,\n                  ...currentTransactionReceipt\n                });\n                clearInterval(listeningInterval);\n              }\n            }, 500);\n          }\n        }\n\n        if (typeof result.wait === \"function\") {\n          await result.wait();\n        }\n\n        return result;\n      } catch (e) {\n        if (DEBUG) console.log(e); // Accounts for Metamask and default signer on all networks\n\n        let message = e.data && e.data.message ? e.data.message : e.error && JSON.parse(JSON.stringify(e.error)).body ? JSON.parse(JSON.parse(JSON.stringify(e.error)).body).error.message : e.data ? e.data : JSON.stringify(e);\n\n        if (!e.error && e.message) {\n          message = e.message;\n        }\n\n        console.log(\"Attempt to clean up:\", message);\n\n        try {\n          let obj = JSON.parse(message);\n\n          if (obj && obj.body) {\n            let errorObj = JSON.parse(obj.body);\n\n            if (errorObj && errorObj.error && errorObj.error.message) {\n              message = errorObj.error.message;\n            }\n          }\n        } catch (e) {//ignore\n        }\n\n        notification.error({\n          message: \"Transaction Error\",\n          description: message\n        });\n\n        if (callback && typeof callback === \"function\") {\n          callback(e);\n        }\n      }\n    };\n  }\n}\n_c = Transactor;\n\nvar _c;\n\n$RefreshReg$(_c, \"Transactor\");","map":{"version":3,"sources":["/Users/untitled/challenge-4-single-pool-dex/packages/react-app/src/helpers/Transactor.js"],"names":["notification","Notify","BLOCKNATIVE_DAPPID","ethers","require","callbacks","DEBUG","Transactor","providerOrSigner","gasPrice","etherscan","tx","callback","signer","network","provider","Signer","isSigner","getNetwork","_isProvider","getSigner","console","log","options","notify","dappId","system","networkId","chainId","transactionHandler","txInformation","possibleFunction","transaction","hash","etherscanNetwork","name","etherscanTxUrl","result","Promise","utils","parseUnits","gasLimit","hexlify","sendTransaction","indexOf","emitter","on","onclick","window","open","info","message","description","placement","txResult","listeningInterval","setInterval","currentTransactionReceipt","getTransactionReceipt","confirmations","clearInterval","wait","e","data","error","JSON","parse","stringify","body","obj","errorObj"],"mappings":"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","sourcesContent":["import { notification } from \"antd\";\nimport Notify from \"bnc-notify\";\nimport { BLOCKNATIVE_DAPPID } from \"../constants\";\n\nconst { ethers } = require(\"ethers\");\n\n// this should probably just be renamed to \"notifier\"\n// it is basically just a wrapper around BlockNative's wonderful Notify.js\n// https://docs.blocknative.com/notify\nconst callbacks = {};\n\nconst DEBUG = true;\n\nexport default function Transactor(providerOrSigner, gasPrice, etherscan) {\n  if (typeof providerOrSigner !== \"undefined\") {\n    // eslint-disable-next-line consistent-return\n    return async (tx, callback) => {\n      let signer;\n      let network;\n      let provider;\n      if (ethers.Signer.isSigner(providerOrSigner) === true) {\n        provider = providerOrSigner.provider;\n        signer = providerOrSigner;\n        network = providerOrSigner.provider && (await providerOrSigner.provider.getNetwork());\n      } else if (providerOrSigner._isProvider) {\n        provider = providerOrSigner;\n        signer = providerOrSigner.getSigner();\n        network = await providerOrSigner.getNetwork();\n      }\n\n      console.log(\"network\", network);\n      var options = null;\n      var notify = null;\n      options = {\n        dappId: BLOCKNATIVE_DAPPID, // GET YOUR OWN KEY AT https://account.blocknative.com\n        system: \"ethereum\",\n        networkId: network.chainId,\n        // darkMode: Boolean, // (default: false)\n        transactionHandler: txInformation => {\n          if (DEBUG) console.log(\"HANDLE TX\", txInformation);\n          const possibleFunction = callbacks[txInformation.transaction.hash];\n          if (typeof possibleFunction === \"function\") {\n            possibleFunction(txInformation.transaction);\n          }\n        },\n      };\n\n      notify = Notify(options);\n\n      let etherscanNetwork = \"\";\n      if (network.name && network.chainId > 1) {\n        etherscanNetwork = network.name + \".\";\n      }\n\n      let etherscanTxUrl = \"https://\" + etherscanNetwork + \"etherscan.io/tx/\";\n      if (network.chainId === 100) {\n        etherscanTxUrl = \"https://blockscout.com/poa/xdai/tx/\";\n      }\n\n      try {\n        let result;\n        if (tx instanceof Promise) {\n          if (DEBUG) console.log(\"AWAITING TX\", tx);\n          result = await tx;\n        } else {\n          if (!tx.gasPrice) {\n            tx.gasPrice = gasPrice || ethers.utils.parseUnits(\"4.1\", \"gwei\");\n          }\n          if (!tx.gasLimit) {\n            tx.gasLimit = ethers.utils.hexlify(120000);\n          }\n          if (DEBUG) console.log(\"RUNNING TX\", tx);\n          result = await signer.sendTransaction(tx);\n        }\n        if (DEBUG) console.log(\"RESULT:\", result);\n        // console.log(\"Notify\", notify);\n\n        if (callback) {\n          callbacks[result.hash] = callback;\n        }\n\n        // if it is a valid Notify.js network, use that, if not, just send a default notification\n        if (notify && [1, 3, 4, 5, 42, 100].indexOf(network.chainId) >= 0) {\n          const { emitter } = notify.hash(result.hash);\n          emitter.on(\"all\", transaction => {\n            return {\n              onclick: () => window.open((etherscan || etherscanTxUrl) + transaction.hash),\n            };\n          });\n        } else {\n          notification.info({\n            message: \"Local Transaction Sent\",\n            description: result.hash,\n            placement: \"bottomRight\",\n          });\n          // on most networks BlockNative will update a transaction handler,\n          // but locally we will set an interval to listen...\n          if (callback) {\n            const txResult = await tx;\n            const listeningInterval = setInterval(async () => {\n              console.log(\"CHECK IN ON THE TX\", txResult, provider);\n              const currentTransactionReceipt = await provider.getTransactionReceipt(txResult.hash);\n              if (currentTransactionReceipt && currentTransactionReceipt.confirmations) {\n                callback({ ...txResult, ...currentTransactionReceipt });\n                clearInterval(listeningInterval);\n              }\n            }, 500);\n          }\n        }\n\n        if (typeof result.wait === \"function\") {\n          await result.wait();\n        }\n\n        return result;\n      } catch (e) {\n        if (DEBUG) console.log(e);\n        // Accounts for Metamask and default signer on all networks\n        let message =\n          e.data && e.data.message\n            ? e.data.message\n            : e.error && JSON.parse(JSON.stringify(e.error)).body\n            ? JSON.parse(JSON.parse(JSON.stringify(e.error)).body).error.message\n            : e.data\n            ? e.data\n            : JSON.stringify(e);\n        if (!e.error && e.message) {\n          message = e.message;\n        }\n\n        console.log(\"Attempt to clean up:\", message);\n        try {\n          let obj = JSON.parse(message);\n          if (obj && obj.body) {\n            let errorObj = JSON.parse(obj.body);\n            if (errorObj && errorObj.error && errorObj.error.message) {\n              message = errorObj.error.message;\n            }\n          }\n        } catch (e) {\n          //ignore\n        }\n\n        notification.error({\n          message: \"Transaction Error\",\n          description: message,\n        });\n        if (callback && typeof callback === \"function\") {\n          callback(e);\n        }\n      }\n    };\n  }\n}\n"]},"metadata":{},"sourceType":"module"}