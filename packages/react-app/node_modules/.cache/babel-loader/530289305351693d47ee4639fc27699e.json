{"ast":null,"code":"import { ethers } from 'ethers';\nimport { useEffect, useMemo, useState } from 'react';\nimport { parseProviderOrSigner } from \"./functions/providerOrSigner\";\n/**\n * Loads your local contracts and gives options to read values from contracts\n  or write transactions into them\n\n   ~ Features ~\n  - localProvider enables reading values from contracts\n  - userProvider enables writing transactions into contracts\n  - Example of keeping track of \"purpose\" variable by loading contracts into readContracts\n    and using ContractReader.js hook:\n    const purpose = useContractReader(readContracts,\"YourContract\", \"purpose\")\n  - Example of using setPurpose function from our contract and writing transactions by Transactor.js helper:\n    tx( writeContracts.YourContract.setPurpose(newPurpose) )\n\n  config can include:\n  - chainId - to hardcode the chainId, irrespective of the providerOrSigner chainId\n  - hardhatNetworkName - to hardcode the hardhat network of interest\n  - customAddresses: { contractName: 0xCustomAddress } to hardcode the address for a given named contract\n  - hardhatContracts: object following the hardhat deploy export format (Json with chainIds as keys, which have hardhat network names as keys, which contain arrays of contracts for each)\n  - externalContracts: object with chainIds as keys, with an array of contracts for each\n * @param providerOrSigner (TEthersProviderOrSigner)\n * @param config (TContractConfig) :: configuration for loader\n * @returns (Record<string, Contract>) :: a record of contractName:contract\n */\n\nexport const useContractLoader = (providerOrSigner, config = {}, chainId) => {\n  const [contracts, setContracts] = useState({});\n  const configDep = useMemo(() => JSON.stringify(config !== null && config !== void 0 ? config : {}), [config]);\n  useEffect(() => {\n    let active = true;\n\n    const loadContracts = async () => {\n      var _a, _b, _c, _d, _e;\n\n      if (providerOrSigner && typeof providerOrSigner !== 'undefined') {\n        console.log(`loading contracts`);\n        console.log(providerOrSigner, config);\n\n        try {\n          // we need to check to see if this providerOrSigner has a signer or not\n          if (typeof providerOrSigner !== 'undefined') {\n            // we need to check to see if this providerOrSigner has a signer or not\n            const {\n              providerNetwork\n            } = await parseProviderOrSigner(providerOrSigner); // find the current chainId based on this order:\n            //  - chainId passed in or a fallback of provider chainId\n\n            const currentChainId = (_a = chainId !== null && chainId !== void 0 ? chainId : providerNetwork === null || providerNetwork === void 0 ? void 0 : providerNetwork.chainId) !== null && _a !== void 0 ? _a : 0; // Type definition\n            //  Record<string, Record<string, Contract>>\n            //  { chainId: { contractName: Contract } }\n\n            const contractList = Object.assign({}, (_b = config.deployedContracts) !== null && _b !== void 0 ? _b : {});\n            const externalContractList = Object.assign({}, (_c = config.externalContracts) !== null && _c !== void 0 ? _c : {});\n            let combinedContracts = {}; // combine partitioned contracts based on all the available and chain id.\n\n            if ((contractList === null || contractList === void 0 ? void 0 : contractList[currentChainId]) != null) {\n              for (const hardhatNetwork in contractList[currentChainId]) {\n                if (Object.prototype.hasOwnProperty.call(contractList[currentChainId], hardhatNetwork)) {\n                  if (!config.hardhatNetworkName || hardhatNetwork === config.hardhatNetworkName) {\n                    combinedContracts = Object.assign(Object.assign({}, combinedContracts), (_e = (_d = contractList === null || contractList === void 0 ? void 0 : contractList[currentChainId]) === null || _d === void 0 ? void 0 : _d[hardhatNetwork]) === null || _e === void 0 ? void 0 : _e.contracts);\n                  }\n                }\n              }\n            }\n\n            if ((externalContractList === null || externalContractList === void 0 ? void 0 : externalContractList[currentChainId]) != null) {\n              combinedContracts = Object.assign(Object.assign({}, combinedContracts), externalContractList[currentChainId].contracts);\n            }\n\n            const newContracts = Object.keys(combinedContracts).reduce((accumulator, contractName) => {\n              const address = config.customAddresses && Object.keys(config.customAddresses).includes(contractName) ? config.customAddresses[contractName] : combinedContracts[contractName].address;\n              accumulator[contractName] = new ethers.Contract(address, combinedContracts[contractName].abi, providerOrSigner);\n              return accumulator;\n            }, {});\n            if (active) setContracts(newContracts);\n          }\n        } catch (e) {\n          console.log('ERROR LOADING CONTRACTS!!', e);\n        }\n      }\n    };\n\n    void loadContracts();\n    return () => {\n      active = false;\n    }; // disable as configDep is used for dep instead of config\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [providerOrSigner, configDep]);\n  return contracts;\n};","map":{"version":3,"sources":["/Users/untitled/challenge-4-single-pool-dex/node_modules/eth-hooks/useContractLoader.js"],"names":["ethers","useEffect","useMemo","useState","parseProviderOrSigner","useContractLoader","providerOrSigner","config","chainId","contracts","setContracts","configDep","JSON","stringify","active","loadContracts","_a","_b","_c","_d","_e","console","log","providerNetwork","currentChainId","contractList","Object","assign","deployedContracts","externalContractList","externalContracts","combinedContracts","hardhatNetwork","prototype","hasOwnProperty","call","hardhatNetworkName","newContracts","keys","reduce","accumulator","contractName","address","customAddresses","includes","Contract","abi","e"],"mappings":"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","sourcesContent":["import { ethers } from 'ethers';\nimport { useEffect, useMemo, useState } from 'react';\nimport { parseProviderOrSigner } from \"./functions/providerOrSigner\";\n/**\n * Loads your local contracts and gives options to read values from contracts\n  or write transactions into them\n\n   ~ Features ~\n  - localProvider enables reading values from contracts\n  - userProvider enables writing transactions into contracts\n  - Example of keeping track of \"purpose\" variable by loading contracts into readContracts\n    and using ContractReader.js hook:\n    const purpose = useContractReader(readContracts,\"YourContract\", \"purpose\")\n  - Example of using setPurpose function from our contract and writing transactions by Transactor.js helper:\n    tx( writeContracts.YourContract.setPurpose(newPurpose) )\n\n  config can include:\n  - chainId - to hardcode the chainId, irrespective of the providerOrSigner chainId\n  - hardhatNetworkName - to hardcode the hardhat network of interest\n  - customAddresses: { contractName: 0xCustomAddress } to hardcode the address for a given named contract\n  - hardhatContracts: object following the hardhat deploy export format (Json with chainIds as keys, which have hardhat network names as keys, which contain arrays of contracts for each)\n  - externalContracts: object with chainIds as keys, with an array of contracts for each\n * @param providerOrSigner (TEthersProviderOrSigner)\n * @param config (TContractConfig) :: configuration for loader\n * @returns (Record<string, Contract>) :: a record of contractName:contract\n */\nexport const useContractLoader = (providerOrSigner, config = {}, chainId) => {\n    const [contracts, setContracts] = useState({});\n    const configDep = useMemo(() => JSON.stringify(config !== null && config !== void 0 ? config : {}), [config]);\n    useEffect(() => {\n        let active = true;\n        const loadContracts = async () => {\n            var _a, _b, _c, _d, _e;\n            if (providerOrSigner && typeof providerOrSigner !== 'undefined') {\n                console.log(`loading contracts`);\n                console.log(providerOrSigner, config);\n                try {\n                    // we need to check to see if this providerOrSigner has a signer or not\n                    if (typeof providerOrSigner !== 'undefined') {\n                        // we need to check to see if this providerOrSigner has a signer or not\n                        const { providerNetwork } = await parseProviderOrSigner(providerOrSigner);\n                        // find the current chainId based on this order:\n                        //  - chainId passed in or a fallback of provider chainId\n                        const currentChainId = (_a = chainId !== null && chainId !== void 0 ? chainId : providerNetwork === null || providerNetwork === void 0 ? void 0 : providerNetwork.chainId) !== null && _a !== void 0 ? _a : 0;\n                        // Type definition\n                        //  Record<string, Record<string, Contract>>\n                        //  { chainId: { contractName: Contract } }\n                        const contractList = Object.assign({}, ((_b = config.deployedContracts) !== null && _b !== void 0 ? _b : {}));\n                        const externalContractList = Object.assign({}, ((_c = config.externalContracts) !== null && _c !== void 0 ? _c : {}));\n                        let combinedContracts = {};\n                        // combine partitioned contracts based on all the available and chain id.\n                        if ((contractList === null || contractList === void 0 ? void 0 : contractList[currentChainId]) != null) {\n                            for (const hardhatNetwork in contractList[currentChainId]) {\n                                if (Object.prototype.hasOwnProperty.call(contractList[currentChainId], hardhatNetwork)) {\n                                    if (!config.hardhatNetworkName || hardhatNetwork === config.hardhatNetworkName) {\n                                        combinedContracts = Object.assign(Object.assign({}, combinedContracts), (_e = (_d = contractList === null || contractList === void 0 ? void 0 : contractList[currentChainId]) === null || _d === void 0 ? void 0 : _d[hardhatNetwork]) === null || _e === void 0 ? void 0 : _e.contracts);\n                                    }\n                                }\n                            }\n                        }\n                        if ((externalContractList === null || externalContractList === void 0 ? void 0 : externalContractList[currentChainId]) != null) {\n                            combinedContracts = Object.assign(Object.assign({}, combinedContracts), externalContractList[currentChainId].contracts);\n                        }\n                        const newContracts = Object.keys(combinedContracts).reduce((accumulator, contractName) => {\n                            const address = config.customAddresses && Object.keys(config.customAddresses).includes(contractName)\n                                ? config.customAddresses[contractName]\n                                : combinedContracts[contractName].address;\n                            accumulator[contractName] = new ethers.Contract(address, combinedContracts[contractName].abi, providerOrSigner);\n                            return accumulator;\n                        }, {});\n                        if (active)\n                            setContracts(newContracts);\n                    }\n                }\n                catch (e) {\n                    console.log('ERROR LOADING CONTRACTS!!', e);\n                }\n            }\n        };\n        void loadContracts();\n        return () => {\n            active = false;\n        };\n        // disable as configDep is used for dep instead of config\n        // eslint-disable-next-line react-hooks/exhaustive-deps\n    }, [providerOrSigner, configDep]);\n    return contracts;\n};\n"]},"metadata":{},"sourceType":"module"}