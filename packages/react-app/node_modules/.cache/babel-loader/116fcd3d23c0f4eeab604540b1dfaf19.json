{"ast":null,"code":"import { useCallback, useEffect, useState } from 'react';\nimport { useOnRepetition } from \"./useOnRepetition\";\nconst DEBUG = false;\n/**\n * Enables you to call functions in contracts and read their values.  It helps keep track of them in the local React states\n *\n  ~ Features ~\n  - Provide readContracts by loading contracts (see more on ContractLoader.js)\n  - Specify the name of the contract, in this case it is \"YourContract\"\n  - Specify the name of the variable in the contract, in this case we keep track of \"purpose\" variable\n  - Pass an args array if the function requires\n  - Pass pollTime - if no pollTime is specified, the function will update on every new block\n * @param contracts (Record<string, Contract>) :: a record of contractName/contract\n * @param contractName (string) :: The contract name\n * @param functionName (string) :: The function name in the contract\n * @param functionArgs (any[]) :: arguments to functions\n * @param pollTime (number) :: optional :: if >0 use polling, else use instead of onBlock event\n * @param formatter ((_value: T) => T) :: optional :: function to format the result\n * @param onChange (string) :: optional :: callback to call with the function\n * @returns (<T>) :: generic return type\n */\n\nexport const useContractReader = (contracts, contractName, functionName, functionArgs = [], pollTime, formatter, onChange) => {\n  var _a;\n\n  const [value, setValue] = useState();\n  useEffect(() => {\n    if (typeof onChange === 'function') {\n      setTimeout(onChange.bind(this, value), 1);\n    }\n  }, [value, onChange]);\n  const updateValue = useCallback(async () => {\n    var _a;\n\n    try {\n      const contractFunction = (_a = contracts === null || contracts === void 0 ? void 0 : contracts[contractName]) === null || _a === void 0 ? void 0 : _a[functionName];\n      let newValue;\n      if (DEBUG) console.log('CALLING ', contractName, functionName, 'with args', functionArgs);\n\n      if (contractFunction) {\n        if (functionArgs && functionArgs.length > 0) {\n          newValue = await contractFunction(...functionArgs);\n          if (DEBUG) console.log('contractName', contractName, 'functionName', functionName, 'functionArgs', functionArgs, 'RESULT:', newValue);\n        } else {\n          newValue = await contractFunction();\n        }\n\n        if (formatter && typeof formatter === 'function') {\n          newValue = formatter(newValue);\n        }\n\n        setValue(newValue);\n      }\n    } catch (e) {\n      console.log(e);\n    }\n  }, [contracts, contractName, functionName, functionArgs, formatter]);\n  useOnRepetition(updateValue, {\n    pollTime,\n    leadingTrigger: (contracts === null || contracts === void 0 ? void 0 : contracts[contractName]) != null,\n    provider: (_a = contracts === null || contracts === void 0 ? void 0 : contracts[contractName]) === null || _a === void 0 ? void 0 : _a.provider\n  }, functionArgs);\n  return value;\n};","map":{"version":3,"sources":["/Users/untitled/challenge-4-single-pool-dex/node_modules/eth-hooks/useContractReader.js"],"names":["useCallback","useEffect","useState","useOnRepetition","DEBUG","useContractReader","contracts","contractName","functionName","functionArgs","pollTime","formatter","onChange","_a","value","setValue","setTimeout","bind","updateValue","contractFunction","newValue","console","log","length","e","leadingTrigger","provider"],"mappings":"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","sourcesContent":["import { useCallback, useEffect, useState } from 'react';\nimport { useOnRepetition } from \"./useOnRepetition\";\nconst DEBUG = false;\n/**\n * Enables you to call functions in contracts and read their values.  It helps keep track of them in the local React states\n *\n  ~ Features ~\n  - Provide readContracts by loading contracts (see more on ContractLoader.js)\n  - Specify the name of the contract, in this case it is \"YourContract\"\n  - Specify the name of the variable in the contract, in this case we keep track of \"purpose\" variable\n  - Pass an args array if the function requires\n  - Pass pollTime - if no pollTime is specified, the function will update on every new block\n * @param contracts (Record<string, Contract>) :: a record of contractName/contract\n * @param contractName (string) :: The contract name\n * @param functionName (string) :: The function name in the contract\n * @param functionArgs (any[]) :: arguments to functions\n * @param pollTime (number) :: optional :: if >0 use polling, else use instead of onBlock event\n * @param formatter ((_value: T) => T) :: optional :: function to format the result\n * @param onChange (string) :: optional :: callback to call with the function\n * @returns (<T>) :: generic return type\n */\nexport const useContractReader = (contracts, contractName, functionName, functionArgs = [], pollTime, formatter, onChange) => {\n    var _a;\n    const [value, setValue] = useState();\n    useEffect(() => {\n        if (typeof onChange === 'function') {\n            setTimeout(onChange.bind(this, value), 1);\n        }\n    }, [value, onChange]);\n    const updateValue = useCallback(async () => {\n        var _a;\n        try {\n            const contractFunction = (_a = contracts === null || contracts === void 0 ? void 0 : contracts[contractName]) === null || _a === void 0 ? void 0 : _a[functionName];\n            let newValue;\n            if (DEBUG)\n                console.log('CALLING ', contractName, functionName, 'with args', functionArgs);\n            if (contractFunction) {\n                if (functionArgs && functionArgs.length > 0) {\n                    newValue = await contractFunction(...functionArgs);\n                    if (DEBUG)\n                        console.log('contractName', contractName, 'functionName', functionName, 'functionArgs', functionArgs, 'RESULT:', newValue);\n                }\n                else {\n                    newValue = await contractFunction();\n                }\n                if (formatter && typeof formatter === 'function') {\n                    newValue = formatter(newValue);\n                }\n                setValue(newValue);\n            }\n        }\n        catch (e) {\n            console.log(e);\n        }\n    }, [contracts, contractName, functionName, functionArgs, formatter]);\n    useOnRepetition(updateValue, {\n        pollTime,\n        leadingTrigger: (contracts === null || contracts === void 0 ? void 0 : contracts[contractName]) != null,\n        provider: (_a = contracts === null || contracts === void 0 ? void 0 : contracts[contractName]) === null || _a === void 0 ? void 0 : _a.provider,\n    }, functionArgs);\n    return value;\n};\n"]},"metadata":{},"sourceType":"module"}