{"ast":null,"code":"import _regeneratorRuntime from\"/Users/untitled/challenge-4-single-pool-dex/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\";import _objectSpread from\"/Users/untitled/challenge-4-single-pool-dex/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/objectSpread2\";import _asyncToGenerator from\"/Users/untitled/challenge-4-single-pool-dex/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";import{notification}from\"antd\";import Notify from\"bnc-notify\";import{BLOCKNATIVE_DAPPID}from\"../constants\";var _require=require(\"ethers\"),ethers=_require.ethers;// this should probably just be renamed to \"notifier\"\n// it is basically just a wrapper around BlockNative's wonderful Notify.js\n// https://docs.blocknative.com/notify\nvar callbacks={};var DEBUG=true;export default function Transactor(providerOrSigner,gasPrice,etherscan){if(typeof providerOrSigner!==\"undefined\"){// eslint-disable-next-line consistent-return\nreturn/*#__PURE__*/function(){var _ref=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee2(tx,callback){var signer,network,provider,options,notify,etherscanNetwork,etherscanTxUrl,result,_notify$hash,emitter,txResult,listeningInterval,message,obj,errorObj;return _regeneratorRuntime.wrap(function _callee2$(_context2){while(1){switch(_context2.prev=_context2.next){case 0:if(!(ethers.Signer.isSigner(providerOrSigner)===true)){_context2.next=11;break;}provider=providerOrSigner.provider;signer=providerOrSigner;_context2.t0=providerOrSigner.provider;if(!_context2.t0){_context2.next=8;break;}_context2.next=7;return providerOrSigner.provider.getNetwork();case 7:_context2.t0=_context2.sent;case 8:network=_context2.t0;_context2.next=17;break;case 11:if(!providerOrSigner._isProvider){_context2.next=17;break;}provider=providerOrSigner;signer=providerOrSigner.getSigner();_context2.next=16;return providerOrSigner.getNetwork();case 16:network=_context2.sent;case 17:console.log(\"network\",network);options=null;notify=null;options={dappId:BLOCKNATIVE_DAPPID,// GET YOUR OWN KEY AT https://account.blocknative.com\nsystem:\"ethereum\",networkId:network.chainId,// darkMode: Boolean, // (default: false)\ntransactionHandler:function transactionHandler(txInformation){if(DEBUG)console.log(\"HANDLE TX\",txInformation);var possibleFunction=callbacks[txInformation.transaction.hash];if(typeof possibleFunction===\"function\"){possibleFunction(txInformation.transaction);}}};notify=Notify(options);etherscanNetwork=\"\";if(network.name&&network.chainId>1){etherscanNetwork=network.name+\".\";}etherscanTxUrl=\"https://\"+etherscanNetwork+\"etherscan.io/tx/\";if(network.chainId===100){etherscanTxUrl=\"https://blockscout.com/poa/xdai/tx/\";}_context2.prev=26;if(!(tx instanceof Promise)){_context2.next=34;break;}if(DEBUG)console.log(\"AWAITING TX\",tx);_context2.next=31;return tx;case 31:result=_context2.sent;_context2.next=40;break;case 34:if(!tx.gasPrice){tx.gasPrice=gasPrice||ethers.utils.parseUnits(\"4.1\",\"gwei\");}if(!tx.gasLimit){tx.gasLimit=ethers.utils.hexlify(120000);}if(DEBUG)console.log(\"RUNNING TX\",tx);_context2.next=39;return signer.sendTransaction(tx);case 39:result=_context2.sent;case 40:if(DEBUG)console.log(\"RESULT:\",result);// console.log(\"Notify\", notify);\nif(callback){callbacks[result.hash]=callback;}// if it is a valid Notify.js network, use that, if not, just send a default notification\nif(!(notify&&[1,3,4,5,42,100].indexOf(network.chainId)>=0)){_context2.next=47;break;}_notify$hash=notify.hash(result.hash),emitter=_notify$hash.emitter;emitter.on(\"all\",function(transaction){return{onclick:function onclick(){return window.open((etherscan||etherscanTxUrl)+transaction.hash);}};});_context2.next=53;break;case 47:notification.info({message:\"Local Transaction Sent\",description:result.hash,placement:\"bottomRight\"});// on most networks BlockNative will update a transaction handler,\n// but locally we will set an interval to listen...\nif(!callback){_context2.next=53;break;}_context2.next=51;return tx;case 51:txResult=_context2.sent;listeningInterval=setInterval(/*#__PURE__*/_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee(){var currentTransactionReceipt;return _regeneratorRuntime.wrap(function _callee$(_context){while(1){switch(_context.prev=_context.next){case 0:console.log(\"CHECK IN ON THE TX\",txResult,provider);_context.next=3;return provider.getTransactionReceipt(txResult.hash);case 3:currentTransactionReceipt=_context.sent;if(currentTransactionReceipt&&currentTransactionReceipt.confirmations){callback(_objectSpread(_objectSpread({},txResult),currentTransactionReceipt));clearInterval(listeningInterval);}case 5:case\"end\":return _context.stop();}}},_callee);})),500);case 53:if(!(typeof result.wait===\"function\")){_context2.next=56;break;}_context2.next=56;return result.wait();case 56:return _context2.abrupt(\"return\",result);case 59:_context2.prev=59;_context2.t1=_context2[\"catch\"](26);if(DEBUG)console.log(_context2.t1);// Accounts for Metamask and default signer on all networks\nmessage=_context2.t1.data&&_context2.t1.data.message?_context2.t1.data.message:_context2.t1.error&&JSON.parse(JSON.stringify(_context2.t1.error)).body?JSON.parse(JSON.parse(JSON.stringify(_context2.t1.error)).body).error.message:_context2.t1.data?_context2.t1.data:JSON.stringify(_context2.t1);if(!_context2.t1.error&&_context2.t1.message){message=_context2.t1.message;}console.log(\"Attempt to clean up:\",message);try{obj=JSON.parse(message);if(obj&&obj.body){errorObj=JSON.parse(obj.body);if(errorObj&&errorObj.error&&errorObj.error.message){message=errorObj.error.message;}}}catch(e){//ignore\n}notification.error({message:\"Transaction Error\",description:message});if(callback&&typeof callback===\"function\"){callback(_context2.t1);}case 68:case\"end\":return _context2.stop();}}},_callee2,null,[[26,59]]);}));return function(_x,_x2){return _ref.apply(this,arguments);};}();}}","map":{"version":3,"sources":["/Users/untitled/challenge-4-single-pool-dex/packages/react-app/src/helpers/Transactor.js"],"names":["notification","Notify","BLOCKNATIVE_DAPPID","require","ethers","callbacks","DEBUG","Transactor","providerOrSigner","gasPrice","etherscan","tx","callback","Signer","isSigner","provider","signer","getNetwork","network","_isProvider","getSigner","console","log","options","notify","dappId","system","networkId","chainId","transactionHandler","txInformation","possibleFunction","transaction","hash","etherscanNetwork","name","etherscanTxUrl","Promise","result","utils","parseUnits","gasLimit","hexlify","sendTransaction","indexOf","emitter","on","onclick","window","open","info","message","description","placement","txResult","listeningInterval","setInterval","getTransactionReceipt","currentTransactionReceipt","confirmations","clearInterval","wait","data","error","JSON","parse","stringify","body","obj","errorObj","e"],"mappings":"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","sourcesContent":["import { notification } from \"antd\";\nimport Notify from \"bnc-notify\";\nimport { BLOCKNATIVE_DAPPID } from \"../constants\";\n\nconst { ethers } = require(\"ethers\");\n\n// this should probably just be renamed to \"notifier\"\n// it is basically just a wrapper around BlockNative's wonderful Notify.js\n// https://docs.blocknative.com/notify\nconst callbacks = {};\n\nconst DEBUG = true;\n\nexport default function Transactor(providerOrSigner, gasPrice, etherscan) {\n  if (typeof providerOrSigner !== \"undefined\") {\n    // eslint-disable-next-line consistent-return\n    return async (tx, callback) => {\n      let signer;\n      let network;\n      let provider;\n      if (ethers.Signer.isSigner(providerOrSigner) === true) {\n        provider = providerOrSigner.provider;\n        signer = providerOrSigner;\n        network = providerOrSigner.provider && (await providerOrSigner.provider.getNetwork());\n      } else if (providerOrSigner._isProvider) {\n        provider = providerOrSigner;\n        signer = providerOrSigner.getSigner();\n        network = await providerOrSigner.getNetwork();\n      }\n\n      console.log(\"network\", network);\n      var options = null;\n      var notify = null;\n      options = {\n        dappId: BLOCKNATIVE_DAPPID, // GET YOUR OWN KEY AT https://account.blocknative.com\n        system: \"ethereum\",\n        networkId: network.chainId,\n        // darkMode: Boolean, // (default: false)\n        transactionHandler: txInformation => {\n          if (DEBUG) console.log(\"HANDLE TX\", txInformation);\n          const possibleFunction = callbacks[txInformation.transaction.hash];\n          if (typeof possibleFunction === \"function\") {\n            possibleFunction(txInformation.transaction);\n          }\n        },\n      };\n\n      notify = Notify(options);\n\n      let etherscanNetwork = \"\";\n      if (network.name && network.chainId > 1) {\n        etherscanNetwork = network.name + \".\";\n      }\n\n      let etherscanTxUrl = \"https://\" + etherscanNetwork + \"etherscan.io/tx/\";\n      if (network.chainId === 100) {\n        etherscanTxUrl = \"https://blockscout.com/poa/xdai/tx/\";\n      }\n\n      try {\n        let result;\n        if (tx instanceof Promise) {\n          if (DEBUG) console.log(\"AWAITING TX\", tx);\n          result = await tx;\n        } else {\n          if (!tx.gasPrice) {\n            tx.gasPrice = gasPrice || ethers.utils.parseUnits(\"4.1\", \"gwei\");\n          }\n          if (!tx.gasLimit) {\n            tx.gasLimit = ethers.utils.hexlify(120000);\n          }\n          if (DEBUG) console.log(\"RUNNING TX\", tx);\n          result = await signer.sendTransaction(tx);\n        }\n        if (DEBUG) console.log(\"RESULT:\", result);\n        // console.log(\"Notify\", notify);\n\n        if (callback) {\n          callbacks[result.hash] = callback;\n        }\n\n        // if it is a valid Notify.js network, use that, if not, just send a default notification\n        if (notify && [1, 3, 4, 5, 42, 100].indexOf(network.chainId) >= 0) {\n          const { emitter } = notify.hash(result.hash);\n          emitter.on(\"all\", transaction => {\n            return {\n              onclick: () => window.open((etherscan || etherscanTxUrl) + transaction.hash),\n            };\n          });\n        } else {\n          notification.info({\n            message: \"Local Transaction Sent\",\n            description: result.hash,\n            placement: \"bottomRight\",\n          });\n          // on most networks BlockNative will update a transaction handler,\n          // but locally we will set an interval to listen...\n          if (callback) {\n            const txResult = await tx;\n            const listeningInterval = setInterval(async () => {\n              console.log(\"CHECK IN ON THE TX\", txResult, provider);\n              const currentTransactionReceipt = await provider.getTransactionReceipt(txResult.hash);\n              if (currentTransactionReceipt && currentTransactionReceipt.confirmations) {\n                callback({ ...txResult, ...currentTransactionReceipt });\n                clearInterval(listeningInterval);\n              }\n            }, 500);\n          }\n        }\n\n        if (typeof result.wait === \"function\") {\n          await result.wait();\n        }\n\n        return result;\n      } catch (e) {\n        if (DEBUG) console.log(e);\n        // Accounts for Metamask and default signer on all networks\n        let message =\n          e.data && e.data.message\n            ? e.data.message\n            : e.error && JSON.parse(JSON.stringify(e.error)).body\n            ? JSON.parse(JSON.parse(JSON.stringify(e.error)).body).error.message\n            : e.data\n            ? e.data\n            : JSON.stringify(e);\n        if (!e.error && e.message) {\n          message = e.message;\n        }\n\n        console.log(\"Attempt to clean up:\", message);\n        try {\n          let obj = JSON.parse(message);\n          if (obj && obj.body) {\n            let errorObj = JSON.parse(obj.body);\n            if (errorObj && errorObj.error && errorObj.error.message) {\n              message = errorObj.error.message;\n            }\n          }\n        } catch (e) {\n          //ignore\n        }\n\n        notification.error({\n          message: \"Transaction Error\",\n          description: message,\n        });\n        if (callback && typeof callback === \"function\") {\n          callback(e);\n        }\n      }\n    };\n  }\n}\n"]},"metadata":{},"sourceType":"module"}