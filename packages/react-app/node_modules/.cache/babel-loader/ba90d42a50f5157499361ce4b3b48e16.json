{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\nconst DEFAULT_PORTS = {\n  'http:': '80',\n  'https:': '443'\n};\nconst URL_REGEX = /^(https?:)?\\/\\/([^/:]+)?(:(\\d+))?/;\nconst opaqueOriginSchemes = ['file:', 'data:'];\n/**\n * Converts a src value into an origin.\n * @param {string} src\n * @return {string} The URL's origin\n */\n\nvar _default = src => {\n  if (src && opaqueOriginSchemes.find(scheme => src.startsWith(scheme))) {\n    // The origin of the child document is an opaque origin and its\n    // serialization is \"null\"\n    // https://html.spec.whatwg.org/multipage/origin.html#origin\n    return 'null';\n  } // Note that if src is undefined, then srcdoc is being used instead of src\n  // and we can follow this same logic below to get the origin of the parent,\n  // which is the origin that we will need to use.\n\n\n  const location = document.location;\n  const regexResult = URL_REGEX.exec(src);\n  let protocol;\n  let hostname;\n  let port;\n\n  if (regexResult) {\n    // It's an absolute URL. Use the parsed info.\n    // regexResult[1] will be undefined if the URL starts with //\n    protocol = regexResult[1] ? regexResult[1] : location.protocol;\n    hostname = regexResult[2];\n    port = regexResult[4];\n  } else {\n    // It's a relative path. Use the current location's info.\n    protocol = location.protocol;\n    hostname = location.hostname;\n    port = location.port;\n  } // If the port is the default for the protocol, we don't want to add it to the origin string\n  // or it won't match the message's event.origin.\n\n\n  const portSuffix = port && port !== DEFAULT_PORTS[protocol] ? `:${port}` : '';\n  return `${protocol}//${hostname}${portSuffix}`;\n};\n\nexports.default = _default;\nmodule.exports = exports.default;","map":{"version":3,"sources":["/Users/untitled/challenge-4-single-pool-dex/node_modules/authereum/node_modules/penpal/lib/getOriginFromSrc.js"],"names":["Object","defineProperty","exports","value","default","DEFAULT_PORTS","URL_REGEX","opaqueOriginSchemes","_default","src","find","scheme","startsWith","location","document","regexResult","exec","protocol","hostname","port","portSuffix","module"],"mappings":"AAAA;;AAEAA,MAAM,CAACC,cAAP,CAAsBC,OAAtB,EAA+B,YAA/B,EAA6C;AAC3CC,EAAAA,KAAK,EAAE;AADoC,CAA7C;AAGAD,OAAO,CAACE,OAAR,GAAkB,KAAK,CAAvB;AACA,MAAMC,aAAa,GAAG;AACpB,WAAS,IADW;AAEpB,YAAU;AAFU,CAAtB;AAIA,MAAMC,SAAS,GAAG,mCAAlB;AACA,MAAMC,mBAAmB,GAAG,CAAC,OAAD,EAAU,OAAV,CAA5B;AACA;AACA;AACA;AACA;AACA;;AAEA,IAAIC,QAAQ,GAAGC,GAAG,IAAI;AACpB,MAAIA,GAAG,IAAIF,mBAAmB,CAACG,IAApB,CAAyBC,MAAM,IAAIF,GAAG,CAACG,UAAJ,CAAeD,MAAf,CAAnC,CAAX,EAAuE;AACrE;AACA;AACA;AACA,WAAO,MAAP;AACD,GANmB,CAMlB;AACF;AACA;;;AAGA,QAAME,QAAQ,GAAGC,QAAQ,CAACD,QAA1B;AACA,QAAME,WAAW,GAAGT,SAAS,CAACU,IAAV,CAAeP,GAAf,CAApB;AACA,MAAIQ,QAAJ;AACA,MAAIC,QAAJ;AACA,MAAIC,IAAJ;;AAEA,MAAIJ,WAAJ,EAAiB;AACf;AACA;AACAE,IAAAA,QAAQ,GAAGF,WAAW,CAAC,CAAD,CAAX,GAAiBA,WAAW,CAAC,CAAD,CAA5B,GAAkCF,QAAQ,CAACI,QAAtD;AACAC,IAAAA,QAAQ,GAAGH,WAAW,CAAC,CAAD,CAAtB;AACAI,IAAAA,IAAI,GAAGJ,WAAW,CAAC,CAAD,CAAlB;AACD,GAND,MAMO;AACL;AACAE,IAAAA,QAAQ,GAAGJ,QAAQ,CAACI,QAApB;AACAC,IAAAA,QAAQ,GAAGL,QAAQ,CAACK,QAApB;AACAC,IAAAA,IAAI,GAAGN,QAAQ,CAACM,IAAhB;AACD,GA5BmB,CA4BlB;AACF;;;AAGA,QAAMC,UAAU,GAAGD,IAAI,IAAIA,IAAI,KAAKd,aAAa,CAACY,QAAD,CAA9B,GAA4C,IAAGE,IAAK,EAApD,GAAwD,EAA3E;AACA,SAAQ,GAAEF,QAAS,KAAIC,QAAS,GAAEE,UAAW,EAA7C;AACD,CAlCD;;AAoCAlB,OAAO,CAACE,OAAR,GAAkBI,QAAlB;AACAa,MAAM,CAACnB,OAAP,GAAiBA,OAAO,CAACE,OAAzB","sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\nconst DEFAULT_PORTS = {\n  'http:': '80',\n  'https:': '443'\n};\nconst URL_REGEX = /^(https?:)?\\/\\/([^/:]+)?(:(\\d+))?/;\nconst opaqueOriginSchemes = ['file:', 'data:'];\n/**\n * Converts a src value into an origin.\n * @param {string} src\n * @return {string} The URL's origin\n */\n\nvar _default = src => {\n  if (src && opaqueOriginSchemes.find(scheme => src.startsWith(scheme))) {\n    // The origin of the child document is an opaque origin and its\n    // serialization is \"null\"\n    // https://html.spec.whatwg.org/multipage/origin.html#origin\n    return 'null';\n  } // Note that if src is undefined, then srcdoc is being used instead of src\n  // and we can follow this same logic below to get the origin of the parent,\n  // which is the origin that we will need to use.\n\n\n  const location = document.location;\n  const regexResult = URL_REGEX.exec(src);\n  let protocol;\n  let hostname;\n  let port;\n\n  if (regexResult) {\n    // It's an absolute URL. Use the parsed info.\n    // regexResult[1] will be undefined if the URL starts with //\n    protocol = regexResult[1] ? regexResult[1] : location.protocol;\n    hostname = regexResult[2];\n    port = regexResult[4];\n  } else {\n    // It's a relative path. Use the current location's info.\n    protocol = location.protocol;\n    hostname = location.hostname;\n    port = location.port;\n  } // If the port is the default for the protocol, we don't want to add it to the origin string\n  // or it won't match the message's event.origin.\n\n\n  const portSuffix = port && port !== DEFAULT_PORTS[protocol] ? `:${port}` : '';\n  return `${protocol}//${hostname}${portSuffix}`;\n};\n\nexports.default = _default;\nmodule.exports = exports.default;"]},"metadata":{},"sourceType":"script"}